---
translatedFrom: en
translatedWarning: Если вы хотите отредактировать этот документ, удалите поле «translationFrom», в противном случае этот документ будет снова автоматически переведен
editLink: https://github.com/ioBroker/ioBroker.docs/edit/master/docs/ru/adapterref/iobroker.systeminfo/README.md
title: Системная информация
hash: YxrTeRdOWPWwOeQiFu2rqefDqRh+wNp9vRhonz20SwA=
---
![Логотип](../../../en/adapterref/iobroker.systeminfo/admin/systeminfo.png)

![версия NPM](http://img.shields.io/npm/v/iobroker.systeminfo.svg)
![Загрузки](https://img.shields.io/npm/dm/iobroker.systeminfo.svg)
![Статус сборки Travis-CI](https://travis-ci.org/frankjoke/ioBroker.systeminfo.svg?branch=master)
![Статус сборки AppVeyor](https://ci.appveyor.com/api/projects/status/pil6266rrtw6l5c0?svg=true)
![НПМ](https://nodei.co/npm/iobroker.systeminfo.png?downloads=true)

# Системная информация
Читает (и записывает) информацию из системы (систем)

## Адаптер обрабатывает (системную) информацию из собственных или других систем и веб-источников
Он генерирует состояния из информации, которую находит с помощью различных методов.

* Команды, выполняемые в операционной системе
* Файлы для чтения в локальных или подключенных системах
* Результаты с веб-страниц или API
* Команды инструментов Nodejs

* Команды и файлы работают также в обоих направлениях, что означает, что вы также можете записывать информацию в систему.
* Это позволяет получать доступ и записывать контакты GPIO на Raspi или OrangePi, а также управлять зеленым или красным светодиодом на Raspi/Opi.
* Это также позволяет получить/установить некоторую системную информацию, доступную через /sys в Lunux.
* Используется часть «системная информация», которая работает в Windows и Linux для

Он обрабатывает типы данных text, HTML, json и XML с помощью специальных механизмов запросов.

### Примечание
* Я хотел выразить благодарность некоторым модулям в Интернете, которые я использовал или реализовал с помощью своего собственного кода. Адаптер использует некоторые внешние модули, такие как [cheerio](https://github.com/cheeriojs/cheerio), [systeminformation](https://github.com/sebhildebrandt/systeminformation) и [node-schedule](https:/ /github.com/node-schedule/node-schedule) как есть. Он также был вдохновлен кодом из [JSONPath](http://goessner.net/articles/JsonPath/index.html#e2) и [scrape-it](https://github.com/IonicaBizau/scrape-it). но их код не использовался напрямую, а был переработан для других нужд.

## Конфигурация
* Настроить в конфиге адаптера (увеличить страницу)
* Сохранил картинку примера конфига [здесь](./admin/Systeminfo.Config.jpg)
    * Первый пункт — это список команд, которые будут выполняться (построчно) при запуске адаптера. Его можно использовать для настройки используемых портов GPIO.
    * Строки, начинающиеся с '`#`', не выполняются
    * Если первый текст '`debug!`', он переводит адаптер в режим отладки, в котором отображается гораздо больше информации о том, что он пытается получить и получить.
* После конфигурации запуска появляется список конфигурации для каждого источника данных, состоящий из
    * Поле имени, которое может включать также
        * Если имя начинается с '`-`' линия будет проигнорирована (отключена), так же как и если нет расписания
        * `[*]`, `[имя, ...]`, `[имя/(значение)]` синтаксис
        * Без всего вышеперечисленного имя используется для создания состояния как есть.
        * Если где-то используется `[]`, имена вставляются сюда разными способами
            * `[*]` если возвращается несколько элементов, они вставляются как числа. Пример: `Meldung[]` сгенерирует `Meldung0`-`Meldung(n)`, если будет возвращено (n) элементов.
            * `[имя1,имя2, ...]`создает именно эти имена (пример `System.Memory_[используется, свободен, доступен]` создаст три состояния с именами `System.Memory_used, System.Memory_free, System.Memory_available`)
            * `[имя/значение]` берет имя из свойства объекта `имя` (может быть другим), а значение из свойства `значение`. Можно использовать любое имя свойства или значения.
            * `[name/]` без значения будет брать имя из `name` и создавать подсостояния для всех других свойств, найденных в этом объекте (пример `System.Network.[iface/]`)

    * `Тип` и `источник` источника информации, который может быть
        * `файл`: Поле `источник` описывает имя файла, который читается
        * `exec`: поле `source` описывает однострочную команду, которая выполняется
        * `info`: поле `source` описывает однострочную командную функцию `systeminfo`
        * `веб`: Поле `источник` описывает читаемый веб-URL (или объект, описывающий доступ, это нужно будет задокументировать позже!).
        * Запросы кэшируются, если одновременно запрашивается несколько записей с одинаковым типом/источником контента! Это означает, что если вы планируете каждую минуту выполнять команду и извлекать два разных элемента данных из одной и той же команды, она запускается только один раз, и только фильтр данных применяется несколько раз.
        * Это помогает не загружать несколько раз одну и ту же страницу, если вы хотите получить больше элементов.

    * `regexp/filter` используется для описания того, как фильтровать полученный текст с помощью
        * Оператор `Regexp`, в котором отдельные элементы должны быть окружены `()`.

        Пример: `/lic\s+(\d+)K\s+(\d+)K\s+(\d+)/m` будет искать текст `lic`, за которым следуют пробелы, а затем числа, заканчивающиеся на `K`, во всех строках, он вернет 3 числа. Это используется в команде `df -BK` Linux, чтобы показать мне размер подключенного общего ресурса NFS, оканчивающегося на «lic» в имени.

        * Заявление `JsonPath`. Я создал специальную версию JsonPath для выбора данных из Json или любых объектов javascript.
            * Его синтаксис состоит из ряда селекторов, которые можно
            * `name` имя свойства
            * `*` любой элемент в этом объекте, это могут быть все свойства или, если объект является массивом, это все элементы массива
            * `[(...)]` оценить `...`, чтобы получить имя свойства, которое будет выбрано. `@` будет использоваться в качестве заполнителя для текущего объекта и может использоваться в операторе eval.
            * `[?(...)]` Отфильтровать элементы этого элемента по ...,

            Пример: `list[?(@.user == 'pi')]` сначала выберет свойство `list` (которое является массивом), а затем отфильтрует список, выбрав только те элементы списка, для которых `.user`установлено на `pi`.

            * `[!(...)]` Возвращает оцененное значение как новый элемент. Таким образом, вы можете вычислить свои собственные данные из найденных объектов.
            * `[name1,name2,name3]` выберет только те имена свойств
            * `[0]` выберет только "первый" (или n-й) элемент или свойство
            * `[start:end:step]` будет брать элементы, начинающиеся с `start` и `<end`, используя `step`. Все должны быть числами или оставлены пустыми. `start` и `end` могут быть отрицательными, что означает, что они начинаются с конца. Пример: `[1:-1:2]` будет брать каждый второй элемент от второго до последнего, но не включая его. Последний будет `[-1::]`, первые 3 будут `[:3:]`, а последние 3 будут `[-3::]`
            * `..` - это селектор рекурсивного спуска, который означает, что `..name` выберет имя свойства в 'любом отделе' объекта!
        * `HTML WebObject query` На случай, если html анализируется, я создал специальный инструмент запросов для выбора элементов из веб-пакетов, похожих на jQuery. Этот инструмент создает объект, который окончательно анализируется с помощью `JsonPath`. **Документация для подражания**

    * Запись `convert` может быть
        * `json` для анализируемых данных json, в веб-записях это означает, что полученный текст будет обрабатываться как json напрямую, а регулярное выражение/фильтр будет оператором/фильтром `JsonParse`.
        * `xml` для XML-данных, это означает, что полученные данные будут преобразованы из XML в json и обработаны, как указано выше
        * `html` Генерирует объект `cheerio`, который затем ищется с помощью специального запроса WebObject.
        * `number` или `boolean` будет пытаться преобразовать значение в числа или логические значения, тогда как для логических чисел числа>0 являются истинными, но также и такие строки, как **on** или **ein** и **true**, оцениваются как истинный.
        * `...` что-нибудь еще вроде `!parseInt(@)` будет оцениваться и в этом случае возвращать **true**, если значение равно `0`, или **false**, если значение больше целого числа.

    * Поле `role/type` описывает поле ioBroker ty и также может называть единицу. Обычный тип поля — это текст или значение, отображаемое в convert.
        * `json` означает, что свойство поля берется из объекта
        * `number|MB` определяет числовое поле с единицей измерения MB (мегабайты)

    * Поле `Write Command` описывает операторы или оценки, которые будут использоваться для обратной записи в элемент. На данный момент он работает только для типов "exec" или "file".
        * Для `exec` это командная строка, которая может включать операторы `@(...)`, которые будут оцениваться. Пример: `gpio write 1 @(@ ? '0' : '1')` будет преобразовано в `gpio write 1 0`, если состояние истинно, и в `gpio write 1 1`, если оно ложно. Это управляет моими ИК-светодиодами, которые загораются, если контакт GPIO «низкий» (0).
        * Для `файла` это простое выражение eval, которое выполняется и записывается в файл. Пример: `@? '1' : '0' `будет писать '1', если значение истинно, и '0', если оно ложно.

    * Последнее — это «расписание». Если он пуст, то он вообще не выполняется! Все расписания с одинаковым значением будут выполняться вместе с одним и тем же кешем.
        * `cron-syntax`, вы можете использовать тот же 'cron'-синтаксис, что и oBroker, использующий расписания inJavascript, которые описаны в [node-schedule](https://github.com/node-schedule/node-schedule)
        * `time-syntax` Я создал специальный синтаксис времени `?:?(:?)`, который упрощает
            * `*:16` будет запрашивать эти данные на 15-й минуте каждого часа.
            * `*/2:1:1` будет запрашивать каждый второй час в 1-ю минуту и 1 секунду.
            * `?s`, `?m`, `?h` с ? если цифры >0, запрос будет выполняться каждые ?секунды, мониты или часы, вы не можете указать несколько элементов одновременно!
        * Расписания сгруппированы по одному и тому же времени, если вы пропустите секунды, как в первом примере выше, им будет присвоено некоторое число, пытающееся избежать одинаковой секунды для всех элементов. Это сделано для того, чтобы не запускать слишком много команд одновременно.

## Известные вопросы
* Бета-тест, запись на веб-страницы не реализована

## Важно/Важно
* Требуется узел >=v4.5

## Changelog
### 0.3.0
* Added save and load config in admin screen

### 0.2.2
* First public beta includes jsonParse and WebQuery parse, jsonParse syntax mistake corrected for selectors
* New icon to separate it from info-Adapter

### 0.2.0
* First public beta includes jsonParse and WebQuery parse

### Todo for later revisions
* Allow import/export of configs to easily add new functions
* Allow access of web pages with authentication and also writing/postng web content

## License

The MIT License (MIT)

Copyright (c) 2017-2019, frankjoke <frankjoke@hotmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.