---
BADGE-NPM version: http://img.shields.io/npm/v/iobroker.radiohead.svg
BADGE-Downloads: https://img.shields.io/npm/dm/iobroker.radiohead.svg
BADGE-Dependency Status: https://img.shields.io/david/crycode-de/iobroker.radiohead.svg
BADGE-Known Vulnerabilities: https://snyk.io/test/github/crycode-de/ioBroker.radiohead/badge.svg
BADGE-NPM: https://nodei.co/npm/iobroker.radiohead.png?downloads=true
BADGE-Travis-CI: http://img.shields.io/travis/crycode-de/ioBroker.radiohead/master.svg
translatedFrom: de
translatedWarning: Если вы хотите отредактировать этот документ, удалите поле «translationFrom», в противном случае этот документ будет снова автоматически переведен
editLink: https://github.com/ioBroker/ioBroker.docs/edit/master/docs/ru/adapterref/iobroker.radiohead/README.md
title: ioBroker.radiohead
hash: V0vrm0V+IiDhGTVilg+5PGS6f5bR/npZhH+Gsx9z72g=
---
![логотип](../../../de/adapterref/iobroker.radiohead/../../admin/radiohead.png)

# IoBroker.radiohead
Адаптер `radiohead` позволяет подключить сеть RadioHead к ioBroker.

Связь происходит через последовательный интерфейс.
Для подключения беспроводного оборудования в качестве шлюза может использоваться небольшой микропроцессор (например, Arduino nano).

[Radiohead](http://www.airspayce.com/mikem/arduino/RadioHead/) является библиотекой радиомодулей с открытым исходным кодом для микропроцессоров.
Он обеспечивает адресные, надежные, многократно передаваемые и подтвержденные сообщения переменной длины.

## Особенности
* Получать сообщения / команды от других узлов в сети RadioHead.
* Отправка сообщений / команд на другие узлы в сети RadioHead.
* Индивидуально настраиваемые объекты для входящих и исходящих данных.
* Возможность отправлять сообщения RadioHead через скрипты.
* Возможность оценивать полученные сообщения RadioHead через скрипты.

Если через последовательный интерфейс получено сообщение, которое соответствует шаблону объекта входящих данных, данные извлекаются из него и записываются адаптером в состояние объекта.

Для отправки данных данные просто записываются в состояние настроенного объекта исходящих данных, и адаптер затем отправляет данные в заданный шаблон.

## Установка
Адаптер доступен через *стабильный* репозиторий и, таким образом, может быть установлен в обычном режиме через интерфейс администратора или командную строку.

В качестве альтернативы, любая существующая предварительная версия может быть установлена через *последний* репозиторий или через URL-адрес `https://github.com/crycode-de/ioBroker.radiohead.git`.

## Конфигурация
Окно конфигурации настаивает на трех ездах:

* Основные настройки
* Входящие данные
* Исходящие данные

### Основные настройки
![Основные настройки](../../../de/adapterref/iobroker.radiohead/./img/haupteinstellungen.png)

#### Последовательный интерфейс
Последовательный порт, по которому осуществляется связь RadioHead.

Примеры:

* `/ dev / ttyUSB0` (Linux)
* `COM1` (Windows)

#### Скорость передачи
Скорость передачи данных, с которой происходит связь. Это должно быть одинаковым для всех узлов в сети RadioHead.

По умолчанию это `9600`.

#### Адрес
Адрес адаптера ioBroker в сети RadioHead.

Может быть указано как шестнадцатеричное число (`0x00` до `0xFE`) или десятичное число (`0` до `254`). Невозможно использовать `0xFF` (или `255`), так как это широковещательный адрес.

#### Надежный режим
В надежном режиме от получателя ожидается подтверждение (ACK) для каждого отправленного сообщения.
Если сообщение не подтверждено в течение установленного времени, оно будет отправлено снова.

Если активирован, RadioHead использует `RHReliableDatagram` вместо `RHDatagram`.

#### Повторения
Количество попыток повторной отправки для каждого сообщения, которое будет отправлено, если подтверждение отсутствует.

По умолчанию это `3`. На `0` установлено отсутствие повторения.

#### Тайм-аут
Время в миллисекундах для ожидания отправки сообщения в подтверждение (ACK).

По умолчанию это `200`.

#### Случайный режим
В беспорядочном режиме могут быть получены сообщения, адресованные любому получателю.

Входящий адрес для входящих данных должен быть установлен правильно, когда эта функция включена.

#### Все данные журнала
Если активировано, каждое полученное и отправленное сообщение записывается в журнал.

### Входящие данные
![Входящие данные](../../../de/adapterref/iobroker.radiohead/./img/eingehende_daten.png)

#### Имя
Имя объекта ioBroker. Должен быть уникальным для входящих данных экземпляра адаптера.

Можно формировать группы, используя точки в именах.

Для каждой записи данных объект создается в соответствии с шаблоном `radiohead.<instanz>.data.in.<name>`.

#### Роль
Роль данных важна для обработки полученных данных.

Переключатели, кнопки и индикаторы оцениваются как истинные значения.
Для всех других ролей числовые значения извлекаются из полученных данных и оцениваются.

#### From-address
Адрес отправителя сообщения в сети RadioHead.

Может быть указано как шестнадцатеричное число (`0x00` до `0xFE`) или десятичное число (`0` до `254`).
Также можно использовать `*` для любого адреса отправителя.

#### По адресу
Адрес получателя сообщения в сети RadioHead.

Может быть указано как шестнадцатеричное число (`0x00` до `0xFF`) или десятичное число (`0` до `255`).
Также можно использовать `*` для любого дополнительного адреса.

* Примечание: * Без активированного беспорядочного режима могут приниматься только сообщения на собственный адрес и широковещательный адрес `0xFF` (или `255`).

#### Данные
Это данные полученного сообщения в отдельных байтах, разделенных запятыми.
На основании этих данных полученное сообщение анализируется и обрабатывается.

Байты могут быть указаны как шестнадцатеричное число (`0x00` до `0xFF`) или десятичное число (`0` до `255`).
В качестве подстановочного знака для любого байта можно использовать `*`.

Байты данных, которые должны быть извлечены для полученного значения, должны быть помечены большими буквами `D`, чтобы данные распознавались во время обработки. Количество последовательных байтов `D` зависит от выбранного типа данных.

** Специальный случай выключатель и индикатор: **

Для переключателей и индикаторов можно указать две группы байтов данных, разделенных точкой с запятой.
Первая группа предназначена для значения `true`, а вторая - для значения `false`.
Если указана только одна группа, то текущий статус включается при получении.

** Примеры **

* Фиксированный байт `0x10`, 32-разрядное число с плавающей запятой, 4 произвольных байта:` 0x01, D, D, D, D, ** ** `
* Два фиксированных байта для кнопки: `0x01,0x00`
* Две группы по одному байту в каждой для коммутатора: `0x05; 0x06`

#### Тип
Это тип данных в ioBroker.
Возможен здесь выбор между *числом* и *значением истинности* В случае значения истинности полученное значение преобразуется в значение истинности (`true` или `false`).

#### Тип данных
Тип данных определяет тип полученных данных и, следовательно, также способ чтения из байтов данных.

Смотрите [типы данных](#datentypen).

#### Единица
Единица соответствующего значения в ioBroker.

#### Фактор и смещение
Коэффициент, который умножает полученное значение и добавляет к нему смещение.

`Wert = (Wert * Faktor) + Offset`

#### Десятичные разряды
Количество десятичных разрядов, до которых округляется полученное значение (после факторинга и вычисления смещения).

### Исходящие данные
![Исходящие данные](../../../de/adapterref/iobroker.radiohead/./img/ausgehende_daten.png)

#### Имя
Имя объекта ioBroker. Должен быть уникальным для исходящих данных экземпляра адаптера.

Можно формировать группы, используя точки в именах.

Для каждой записи данных объект создается в соответствии с шаблоном `radiohead.<instanz>.data.out.<name>`.

#### Роль
Роль данных важна для обработки отправляемых данных.

Переключатели, кнопки и индикаторы отправляются как значения истинности.
Для всех других ролей числовые значения встраиваются в отправляемые данные.

#### По адресу
Адрес получателя сообщения в сети RadioHead.

Может быть указано как шестнадцатеричное число (`0x00` до `0xFF`) или десятичное число (`0` до `255`).

Для широковещательных сообщений на все узлы должен использоваться адрес `0xFF` (или `255`).

#### Данные
Это данные сообщения, которое будет отправлено в отдельных байтах, разделенных запятыми.
На основании этих данных устанавливается сообщение для отправки.

Байты могут быть указаны как шестнадцатеричное число (`0x00` до `0xFF`) или десятичное число (`0` до `255`).

Байты, в которых должны использоваться данные для отправки, должны быть помечены большими буквами `D`. Количество последовательных байтов `D` зависит от выбранного типа данных.

** Специальный случай выключатель и индикатор: **

Для переключателей и индикаторов можно указать две группы байтов данных, разделенных точкой с запятой.
Первая группа предназначена для значения `true`, а вторая - для значения `false`.
Если указана только одна группа, эта группа будет отправлена всегда.

** Примеры **

* Фиксированный байт `0x42`, 16-разрядное целое число:` 0x42, D, D`
* Два фиксированных байта для кнопки: `0x01,0x02`
* Две группы по два байта в каждой для коммутатора: `0x01,0x00; 0x01,0xFF`

#### Тип
Это тип данных в ioBroker.
Возможен здесь выбор между *числом* и *значением истинности* Для значения истинности отправляемое значение преобразуется в `0x01` (`true`) или `0x00` (`false`).

#### Тип данных
Тип данных определяет тип данных для отправки и, следовательно, также метод записи в байтах данных.

Смотрите [типы данных](#datentypen).

#### Единица
Единица соответствующего значения в ioBroker.

## Типы данных
Следующие типы данных доступны при получении и отправке данных:

| Тип данных | Описание | Диапазон значений | Байты данных |
|---|---|---|---|
| `int8` | 8-разрядное целое число со знаком | От -128 до 127 | 1 |
| `int16_le`, `int16_be` | 16-разрядное целое число со знаком | От 0 до 32767 | 2 |
| `uint16_le`, `uint16_be` | 16-разрядное целое число без знака | От 0 до 65535 | 2 |
| `int32_le`, `int32_be` | 32-разрядное целое число со знаком | От 0 до 4294967295 | 4 |
| `uint32_le`, `uint32_be` | 32-разрядное целое число без знака | От 0 до 4294967295 | 4 |
| `float32_le`, `float32_be` | 32-разрядное число с плавающей точкой | От -3,4E + 38 до + 3,4E + 38, 7 десятичных знаков | 4 |
| `double64_le`, `double64_be` | 64-разрядное число с плавающей точкой | -1,7E + 308 до + 1,7E + 30, 16 знаков после запятой | 8 |
| `double64_le`,` double64_be` | 64-разрядное число с плавающей точкой | -1,7E + 308 до + 1,7E + 30, 16 знаков после запятой | 8 |

Окончания `_le` и `_be` каждый обозначает порядок байтов (порядковый номер) для типов данных с более чем одним байтом. Это зависит от того, как удаленная станция отправляет или обрабатывает данные.

* `_le` - *little-endian* сначала младший байт
* `_be` - *big-endian* сначала старший байт

## Использовать в скриптах
С помощью скриптов можно отправлять сообщения RadioHead и оценивать полученные сообщения.

### Отправить через скрипт
Для отправки через скрипт можно использовать функцию `sendTo`.

** Пример: **

```js
sendTo('radiohead.0', 'send', {
    to: 0x02, // Zu-Adresse
    data: [0x01,0x02,255] // zu sendende Daten-Bytes als Array oder Buffer
}, (ret) => {
    log('ret: ' + JSON.stringify(ret));
    // -> ret: {}
    if (ret.error) {
        log('error sending message', 'warn');
    }
});
```

Если сообщение не было успешно отправлено, то для `ret.error` устанавливается соответствующая ошибка.

### Оценивать полученные сообщения через скрипт
Для каждого полученного сообщения объект `radiohead.<instanz>.data.incoming` обновляется, и значение устанавливается для объекта с полученными данными.
Это изменение может быть оценено соответственно.

** Пример: **

```js
on({id: "radiohead.0.data.incoming", change:'any'}, (obj) => {
    log('incoming changed: ' + JSON.stringify(obj.state.val));
    // -> incoming changed: {"data":[1,0],"length":2,"headerTo":1,"headerFrom":2,"headerId":47,"headerFlags":0}
});
```

## Информация об адаптере
Каждый экземпляр адаптера предоставляет следующую информацию:

| Объект | Описание |
|---|---|
| info.connection | Индикатор того, подключен ли адаптер к последовательному порту |
| info.lastReceived | Время, когда было получено последнее сообщение RadioHead |
| info.lastSentOk | Время, когда последнее сообщение RadioHead было успешно отправлено |
| info.lastSentError | Время, когда последнее сообщение RadioHead было отправлено неправильно |
| info.receivedCount | Количество полученных сообщений RadioHead |
| info.retransmissionsCount | Количество попыток повторной отправки сообщений |
| info.sentErrorCount | Количество неправильно отправленных сообщений |
| info.sentOkCount | Количество успешно отправленных сообщений |

При необходимости счетчики сообщений могут быть сброшены на 0 путем записи в объект `actions.resetCounters`.

## Changelog
### 1.0.2 (2019-09-08)
* (Peter Müller) dependency updates and bugfixes

### 1.0.1 (2019-07-30)
* (Peter Müller) license  update

### 1.0.0 (2019-07-28)
* (Peter Müller) initial release

## License

Copyright (c) 2019 Peter Müller <peter@crycode.de>