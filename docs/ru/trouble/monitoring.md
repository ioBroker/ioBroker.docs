---
translatedFrom: de
translatedWarning: Если вы хотите отредактировать этот документ, удалите поле «translationFrom», в противном случае этот документ будет снова автоматически переведен
editLink: https://github.com/ioBroker/ioBroker.docs/edit/master/docs/ru/trouble/monitoring.md
title: мониторинг производительности
hash: f9k8uTEaRQI9WucjkJjFqbIX8d32IdLTh8VwMNiVFIk=
---
# Мониторинг производительности
Отправной точкой для анализа производительности в ioBroker является список объектов в админке.
Он предоставляет системную информацию о хосте или хостах (ioBroker поддерживает несколько хостов) и отдельных адаптерах. Доступ к этой информации осуществляется путем переключения списка объектов в экспертный режим:

![объекты](../../de/trouble/media/monitoring1.png)

## Значения производительности хостов
Хост на языке ioBroker - это машина, на которой выполняется процесс контроллера ioBroker js.
В среде с несколькими хостами для распределения нагрузки это также может быть несколько компьютеров.
Даже соответствующая операционная система может отличаться.
Хорошая задача, например, Стеки кластера Raspberry Pi справляются с аппаратным ограничением в 1 ГБ ОЗУ.

![Джефф Герлинг, YouTube](../../de/trouble/media/monitoring2.png)

Контроллер js ioBrokers координирует запуск и остановку адаптеров и выполняет дополнительные задачи по управлению системой в фоновом режиме. В Admin можно найти значения производительности для соответствующего хост-компьютера и контроллера js под идентификатором `system.host.<Name_des_Hostrechners>`.

Вот список отдельных показателей и их значения:

| Ключевая фигура | Тип данных | Блок | Описание |
|----------|----------|---------|--------------|
| **живой** | Логика | нет | Указывает, активен ли контроллер ioBroker js на хосте |
| **диск свободен** | Номер | МиБ | Свободное место на логическом диске, на котором установлен ioBroker *bi = двоичное число (1 МБ = 1 000 000 байт) <(1 МБ = 1 048 576 байт = 1 × 1024 × 1024 байт)* |
| **размер диска** | Номер | МиБ | Общий размер логического тома, на котором установлен ioBroker |
| **DiskWarning** | Номер | % | Здесь вы можете ввести процент. Предупреждение будет отображаться в администраторе, если свободное место на томе падает ниже этого значения (например, 20). Это особенно полезно, если адаптер истории активен. ![экран](../../de/trouble/media/monitoring3.png) |
| **freemem** | Номер | МБ | Общая доступная оперативная память хоста Системная память |
| **inputCount** | Номер | / 15с | Количество изменений в государственных значениях. Событие ввода может, например, путем создания или установки значения |
| **нагрузка** | Номер | % | Общая системная нагрузка на процессор, в среднем за одну секунду каждый. Не удивляйтесь, под Windows это значение всегда 0 |
| **мем** | Номер | % | Использование памяти. Связь между свободной памятью и общей системной памятью |
| **memHeapTotal** | Номер | МБ | Размер кучи памяти, зарезервированной контроллером js |
| **memHeapUsed** | Номер | МБ | Размер памяти кучи, используемой контроллером js |
| **memRss** | Номер | МБ | Resident Set, общий объем памяти, используемой контроллером js в RAM |
| **outputCount** | Номер | / 15с | Выходные события включают в себя такие действия, как сравнение значений, запись значения в базу данных состояний, события из-за подписок или регистрация адаптера, например, в. Чтобы получить утверждения о .connected | или .alive-состояниях. Таким образом, также происходит 8 событий, которые обычно находятся в выходном значении события в списке экземпляров. |
| **время работы** | Номер | с | Время работы ioBroker на этом хосте с момента последней перезагрузки |

Следующая диаграмма символически показывает, как куча, код и стек влияют на общее использование памяти **memRss** процесса nodejs:

![экран](../../de/trouble/media/monitoring4.png)

Если главный js-контроллер сам предоставляет базу данных объектов и состояний для всей системы, эта мера является отличным способом определить разницу между 300 и 3000 объектами ioBroker в использовании памяти. Например, в моей системе Windows это значение составляет 3500 объектов, а 2700 состояний находятся в диапазоне от 75 до 128 МБ. Приветствую в nodejs интегрированную сборку мусора.
С другой стороны, если я использую Redis в качестве базы данных состояний, использование памяти для контроллера js сократится до 50 МБ.
(Теперь Redis нужно дополнительно 25 МБ = снова 75 МБ;))

Если число изменений состояния превышает производительность обработки зависимых потребителей событий (например, javascript с триггерами on:), в базах данных в памяти создается очередь.
Это видно по потреблению памяти контроллера js. Как только загрузка системы снова падает, и потребителям событий дается достаточно времени для обработки ожидающих изменений значения, значение memRss возвращается к своему первоначальному значению:

![экран](../../de/trouble/media/monitoring5.png)

Как это часто бывает в этой среде, нельзя делать точные заявления о причине ошибок на основе фиксированных значений.
Однако часто помогает наблюдение за безошибочной системой (= эталонные значения), а затем сравнение **той же системы** в условиях неисправности. Кроме того, очень полезно записать ту или иную точку данных в гистограммах, например, Чтобы уловить тенденции и выбросы.

## Значения производительности адаптеров
Каждый адаптер имеет свои собственные показатели производительности.
Они хранятся под идентификатором `system.adapter.<Name_des_Adapters>.<Instanz>` и немного отличаются от идентификатора хоста.

| Ключевая фигура | Тип данных | Блок | Описание |
|----------|----------|---------|--------------|
| **живой** | Логика | нет | Указывает, активен ли адаптер |
| **подключен** | Логика | нет | Указывает, сообщил ли адаптер в течение последних 30 секунд |
| **inputCount** | Номер | / 15с | Количество изменений в государственных значениях. Событие ввода может, например, путем создания или установки значения |
| **memHeapTotal** | Номер | МБ | Размер кучи памяти, зарезервированной адаптером |
| **memHeapUsed** | Номер | МБ | Размер памяти кучи, используемой адаптером |
| **memRss** | Номер | МБ | Резидентный набор, общий объем памяти, используемой адаптером в оперативной памяти |
| **inputCount** | Номер | / 15с | Количество изменений значений состояния. Событие ввода может, например, создания или установки значения |
| **outputCount** | Номер | / 15с | Выходные события включают в себя такие действия, как сравнение значений, запись значения в базу данных состояний, события из-за подписок или регистрация адаптера, например, в. Чтобы получить утверждения о .connected- или .alive-состояниях. Таким образом, также происходит 8 событий, которые обычно находятся в выходном значении события в списке экземпляров. |
| **время работы** | Номер | с | Время работы адаптера с момента запуска адаптера |

Например, если адаптер Javascript неожиданно перепрыгивает на несколько тысяч после изменения сценария на 100 **событий inputCount** существует сильное предположение, что цикл запуска, т.е. Кольцевая ссылка встроена в его сценарий.

Также полезно рассмотреть ** memRss ** для Обнаружение утечек памяти через скрипты или в адаптерах. При подключенных ** живых ** и ** ** вы можете визуально визуализировать состояние адаптера или подавить отображение неверных данных, если адаптер не может предоставить новые значения.

## Outlook и вопрос
Поскольку я просто показываю картину как взгляд в будущее (и в моей среде разработки):

![экран](../../de/trouble/media/monitoring6.png)

Адаптеры Мне не хватает дисплея отдельного адаптера, вызывающего загрузку процессора **процессор** Ведь вы хотите узнать даже без ресурсоемкой установки дополнительного адаптера мониторинга, который является виновником в системе. После того, как nodejs является однопоточным, отображение здесь относится к ядру процессора. Больше 100% здесь нет.

Использование процессоров с несколькими ядрами не помогает, если адаптер показывает постоянно высокие значения.
В этом случае целесообразны только более быстрый процессор (обычно более высокая тактовая частота), оптимизация программного кода или распределение нагрузки по нескольким адаптерам (если возможно).

Код **cputime** позволяет оценить общее количество процессорного времени, использованного адаптером с момента запуска.
Он предоставляет информацию о частоте или интенсивности (интенсивность ключевых слов), с которой программа запрашивает процессор.
Эта сумма практически всегда ниже, чем все время работы адаптера **uptime** так как адаптер практически не посылает заказов процессору даже при интенсивном использовании.

Здесь вы можете увидеть, как выглядят различные показатели и как выглядит реакция адаптера Javascript на внезапную волну требований во Flot:

![экран](../../de/trouble/media/monitoring7.png)

Кстати, адаптер Javascript был уже настолько занят, что больше не мог сразу принимать все события.
Это сформировало очередь событий.

Для того, чтобы мы могли немного больше узнать о нагрузке на <u>хост</u> и особенно о мастере всех адаптеров, js-controller, я также предоставил некоторые счетчики производительности для этого. Следующее утверждение показывает возможный внешний вид счетчика производительности хоста.

Как уже говорилось, это подлежит проверке Bluefox и в ближайшее время только с контроллера js 1.5.x:

![экран](../../de/trouble/media/monitoring8.png)

Чтобы подвести итог значения точек данных:

| Ключевая фигура | Тип данных | Блок | Источник данных | Описание |
|----------|----------|---------|-------------|--------------|
| **живой** | Логика | нет | JS-контроллер | Указывает, активен ли контроллер ioBroker js на хосте. Автоматически меняется на ложь | 25 секунд после смерти  |
| **процессор** | Номер | % Использование ядра | JS-контроллер | Определяет использование ядра, на котором работает контроллер js. Здесь более 100% не работает, потому что nodejs однопоточный |
| **процессор** | Номер | с | JS-контроллер | Время процессора (англ. CPU time) обозначает измеренное время в секундах, в течение которого контроллер js фактически отправлял команды процессору с момента последнего запуска программы. Эта сумма практически всегда меньше, чем общее время выполнения (uptime) программы, так как она почти никогда не отправляет запросы процессору даже при интенсивном использовании. |
| **диск свободен** | Номер | МиБ | | Свободное место на логическом диске, на котором установлен ioBroker *bi = двоичное число (1 МБ = 1 000 000 байт) <(1 МБ = 1 048 576 байт = 1 × 1024 × 1024 байт)* |
| **размер диска** | Номер | МиБ | | Общий размер логического тома, на котором установлен ioBroker |
| **DiskWarning** | Номер | % | | Здесь вы можете ввести процент. Предупреждение будет отображаться в администраторе, если свободное место на томе падает ниже этого значения (например, 20). Это особенно полезно, если адаптер истории активен. ![экран](../../de/trouble/media|monitoring9.png) |
| **freemem** | Номер | МБ | | Общая доступная оперативная память хоста Системная память |
| **inputCount** | Номер | / 15с | JS-контроллер | Количество изменений в государственных значениях. Событие ввода может, например, путем создания или установки значения |
| **нагрузка** | Номер | | | Общая нагрузка системы на все ядра ЦП, в среднем за одну секунду каждое. Так, например, Калькулятор с 8 ядрами процессора -> значение 7,9 = система почти перегружена, 0,1 = ничего не происходит; 4 ядра -> значение 3.9 = перегрузка - если постоянно, 0.1 = ничего не происходит |
| **мем** | Номер | % | | Использование памяти. Связь между свободной памятью и общей системной памятью |
| **memHeapTotal** | Номер | МБ | JS-контроллер | Размер кучи памяти, зарезервированной js-контроллером |
| **memHeapUsed** | Номер | МБ | JS-контроллер | Размер памяти кучи, используемой js-контроллером |
| **memRss** | Номер | МБ | JS-контроллер | Резидентный набор, общий размер памяти, используемой контроллером js в RAM |
| **outputCount** | Номер | / 15с | JS-контроллер | Выходные события включают в себя такие действия, как сравнение значений, запись значения в базу данных состояний, события из-за подписок или ведение журнала. Так и здесь происходит более 10 событий |
| **memAvailable** | Номер | МБ | JS-контроллер | (Только для систем * nix). Доступное свободное пространство для новых требований к хранилищу без необходимости начинать разгрузку использованного хранилища. Рассчитывается из MemFree, Active (файл), Inactive (файл), SReclaimable и нижних порогов из `/proc/zoneinfo`. <br> Смотрите [https://git.kernel.org](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773) |
| **memAvailable** | Номер | МБ | JS-контроллер | (Только для систем * nix). Доступное свободное пространство для новых требований к хранилищу без необходимости начинать разгрузку использованного хранилища. Рассчитывается из MemFree, Active (файл), Inactive (файл), SReclaimable и нижних порогов из `/ proc / zoneinfo`. <br> Смотрите [https://git.kernel.org] (https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773) |