---
translatedFrom: de
translatedWarning: Если вы хотите отредактировать этот документ, удалите поле «translationFrom», в противном случае этот документ будет снова автоматически переведен
editLink: https://github.com/ioBroker/ioBroker.docs/edit/master/docs/ru/trouble/monitoring.md
title: Мониторинг производительности
hash: f9k8uTEaRQI9WucjkJjFqbIX8d32IdLTh8VwMNiVFIk=
---
# Мониторинг производительности
Отправной точкой анализа производительности в ioBroker является список объектов в панели администратора.
Там представлена системная информация о хостах (ioBroker поддерживает работу с несколькими хостами) и отдельных адаптерах. Доступ к этой информации можно получить, переключив список объектов в экспертный режим:

![Объекты](../../de/trouble/media/monitoring1.png)

## Значения производительности хостов
Хост, на языке ioBroker, — это машина, на которой выполняется процесс контроллера js ioBroker.
В многохостовой среде это также может быть несколько компьютеров для распределения нагрузки.
Даже используемая операционная система может отличаться.
Хорошая задача для стеков кластеров Raspberry Pi, например, справиться с аппаратным ограничением ОЗУ в 1 ГБ.

![Джефф Гирлинг, YouTube](../../de/trouble/media/monitoring2.png)

Контроллер ioBrokers js координирует запуск и остановку адаптеров и выполняет другие задачи управления системой в фоновом режиме. В администраторе вы можете найти значения производительности для соответствующего хост-компьютера и контроллера js под идентификатором `system.host.<Name_des_Hostrechners>`.

Вот список отдельных ключевых показателей и их значения:

| Ключевая фигура | тип данных | Единица | Описание |
|----------|----------|---------|--------------|
| **жив** | Логика | нет | Указывает, активен ли js-контроллер ioBroker на хосте |
| **дискБесплатно** | номер | МиБ | Свободное место на логическом диске, на котором установлен ioBroker *bi = двоичное кратное (1 МБ = 1 000 000 байт) < (1 МБ = 1 048 576 байт = 1 × 1024 × 1024 байт)* |
| **размер_диска** | номер | МиБ | Общий размер логического тома, на котором установлен ioBroker |
| **дискПредупреждение** | номер | % | Здесь вы можете ввести процентное значение. В админке выводится предупреждение, если свободное место на диске упадет ниже этого значения (например 20). Это особенно полезно, если адаптер истории активен. ![экран](../../de/trouble/media/monitoring3.png) |
| **фримем** | номер | МБ | Общий объем доступной оперативной памяти хоста |
| **inputCount** | номер | /15с | Количество изменений значений состояния. Событие ввода может быть инициировано, например, путем создания или установки значения |
| **загрузить** | номер | % | Общая системная загрузка ЦП, усредненная за одну секунду. Не удивляйтесь, в Windows это значение всегда равно 0 |
| **мем** | номер | % | Использование памяти. Соотношение между свободной памятью и общей системной памятью |
| **memHeapTotal** | номер | МБ | Размер кучи памяти, зарезервированной контроллером js |
| **memHeapUsed** | номер | МБ | Размер кучи памяти, используемой контроллером js |
| **мемРсс** | номер | МБ | Резидентный набор, общий размер памяти, используемой js-контроллером в оперативной памяти |
| **выходной счетчик** | номер | /15с | Выходные события включают в себя такие действия, как сравнение значений, запись значения в базу данных состояний, события, связанные с подписками или, например, регистрацию адаптера для получения информации о состояниях .connected|или .alive. Именно так возникают 8 событий, которые обычно находятся в списке экземпляров выходного значения события. |
| **время безотказной работы** | номер | s | Время работы ioBroker на этом хосте с момента последнего перезапуска |

На следующей диаграмме символически показано, как куча, код и стек влияют на общее использование памяти **memRss** процессом nodejs:

![экран](../../de/trouble/media/monitoring4.png)

Если главный контроллер js сам предоставляет базу данных объектов и состояний для всей системы, вы можете использовать этот показатель, чтобы определить разницу между 300 и 3000 объектами ioBroker с точки зрения потребления памяти. Например, в моей системе Windows это значение колеблется от 75 до 128 МБ при 3500 объектах и 2700 состояниях. Сборщик мусора, интегрированный в nodejs, передает привет.
Однако если я использую Redis в качестве базы данных состояний, потребление памяти js-контроллером падает до 50 МБ.
(Теперь Redis снова нужны дополнительные 25 МБ = 75 МБ;))

Если количество изменений состояния превышает возможности обработки зависимых потребителей событий (например, Javascript с триггерами on:), в базах данных в памяти создается очередь.
Это видно по потреблению памяти js-контроллера. Как только нагрузка на систему снова падает и потребителям событий предоставляется достаточно времени для обработки ожидающих изменений значений, значение memRss возвращается к исходному значению:

![экран](../../de/trouble/media/monitoring5.png)

Как это часто бывает в этой среде, невозможно сделать точные заявления о причине ошибок на основе фиксированных значений.
Однако часто помогает наблюдение за системой, которая работает без ошибок (= эталонные значения), а затем сравнение **той же системы** в условиях ошибки. Кроме того, очень полезно записывать в историю одну или две точки данных, например, для записи тенденций и выбросов.

## Значения производительности адаптеров
Каждый адаптер имеет свои собственные показатели производительности.
Каждый из них хранится под идентификатором `system.adapter.<Name_des_Adapters>.<Instanz>` и немного отличается от идентификатора хоста.

| Ключевая фигура | тип данных | Единица | Описание |
|----------|----------|---------|--------------|
| **жив** | Логика | нет | Показывает, активирован ли адаптер |
| **подключено** | Логика | нет | Предоставляет информацию о том, ответил ли адаптер в течение последних 30 секунд |
| **inputCount** | номер | /15с | Количество изменений значений состояния. Событие ввода может быть инициировано, например, путем создания или установки значения |
| **memHeapTotal** | номер | МБ | Размер кучи памяти, зарезервированной адаптером |
| **memHeapUsed** | номер | МБ | Размер кучи памяти, используемой адаптером |
| **мемРсс** | номер | МБ | Resident Set, общий объем памяти, используемый адаптером в оперативной памяти |
| **inputCount** | номер | /15с | Количество изменений значений состояния. Событие ввода может быть инициировано, например, путем создания или установки значения |
| **выходной счетчик** | номер | /15с | Выходные события включают в себя такие действия, как сравнение значений, запись значения в базу данных состояний, события на основе подписок или регистрацию адаптера для получения информации, например, о состояниях .connected или .alive. Именно так возникают 8 событий, которые обычно находятся в списке экземпляров выходного значения события. |
| **время безотказной работы** | номер | s | Время работы адаптера с момента запуска адаптера |

Если, например, адаптер Javascript внезапно подскакивает со 100 событий **inputCount** до нескольких тысяч после изменения сценария, есть сильное подозрение, что вы встроили в свой сценарий триггерный цикл, то есть кольцевую ссылку.

Также полезно просмотреть **memRss**, например, для обнаружения утечек памяти через сценарии или адаптеры. С помощью **активного** и **подключенного** вы можете легко визуализировать состояние адаптера или подавить отображение неверных данных, если адаптер не может предоставить новые значения.

## Перспектива и вопрос
Я просто покажу вам картинку как взгляд в будущее (и на мою среду разработки):

![экран](../../de/trouble/media/monitoring6.png)

Для адаптеров мне не хватает отображения загрузки процессора **cpu**, вызванной отдельным адаптером.
Ведь вы все равно хотите знать, кто виновник в системе, даже без необходимости установки дополнительных адаптеров мониторинга, требующих много ресурсов. Поскольку nodejs является однопоточным, отображение здесь относится к одному ядру ЦП. Больше 100% здесь невозможно.

Использование процессоров с несколькими ядрами не поможет, если адаптер постоянно показывает высокие значения.
В данном случае эффективен только более быстрый процессор (в народе более высокая тактовая частота), оптимизация программного кода или разделение нагрузки на несколько адаптеров (если это возможно).

Вы можете использовать показатель **cputime** для оценки суммы процессорного времени, использованного адаптером с момента его запуска.
Он предоставляет информацию о частоте или интенсивности (ключевое слово: интенсивные вычисления), с которой программа требует процессора.
Эта сумма практически всегда меньше, чем все время работы адаптера **uptime**, поскольку адаптер редко отправляет команды процессору непрерывно, даже при интенсивном использовании.

Здесь можно увидеть, как взаимодействуют различные метрики и как выглядит реакция Javascript-адаптера на внезапную волну запросов во Flot:

![экран](../../de/trouble/media/monitoring7.png)

Кстати, Javascript-адаптер уже был настолько занят, что уже не мог принимать все события сразу.
Образовалась очередь событий.

Чтобы мы могли узнать немного больше о нагрузке на <u>хост</u> и особенно о мастере всех адаптеров, js-контроллере, я также предоставил для него несколько счетчиков производительности. В следующем обзоре показано возможное будущее появление счетчиков производительности хоста.

Как я уже сказал, это применимо при условии проверки Bluefox и только начиная с js-контроллера 1.5.x:

![экран](../../de/trouble/media/monitoring8.png)

Подводя итог значению точек данных:

| Ключевая фигура | тип данных | Единица | Источник данных | Описание |
|----------|----------|---------|-------------|--------------|
| **жив** | Логика | нет | js-контроллер | Указывает, активен ли js-контроллер ioBroker на хосте. Автоматически переключается на ложь через 25 секунд после смерти |
| **процессор** | номер | % использования ядра | js-контроллер | Указывает загрузку ядра, на котором работает js-контроллер. Гораздо больше 100% здесь невозможно, так как nodejs однопоточный |
| **время процессора** | номер | s | js-контроллер | Время процессора (время ЦП) — это измеренное время в секундах, в течение которого контроллер js фактически отправлял команды процессору с момента последнего запуска программы. Эта сумма практически всегда ниже всего времени работы (аптайма) программы, так как она редко посылает команды процессору непрерывно, даже при интенсивном использовании. |
| **дискБесплатно** | номер | МиБ |               | Свободное место на логическом диске, на котором установлен ioBroker *bi = двоичное кратное (1 МБ = 1 000 000 байт) < (1 МБ = 1 048 576 байт = 1 × 1024 × 1024 байт)* |
| **размер_диска** | номер | МиБ |               | Общий размер логического тома, на котором установлен ioBroker |
| **дискПредупреждение** | номер | % |               | Здесь вы можете ввести процентное значение. В админке выводится предупреждение, если свободное место на диске упадет ниже этого значения (например 20). Это особенно полезно, если адаптер истории активен. ![экран](../../de/trouble/media|monitoring9.png) |
| **фримем** | номер | МБ |               | Общий объем доступной оперативной памяти хоста |
| **inputCount** | номер | /15с | js-контроллер | Количество изменений значений состояния. Событие ввода может быть инициировано, например, путем создания или установки значения |
| **загрузить** | номер |       |               | Общая загрузка системы по всем ядрам ЦП, в среднем за одну секунду каждое. Например, компьютер с 8 ядрами ЦП -> значение 7,9 = система почти перегружена, 0,1 = ничего не происходит; 4 ядра -> значение 3,9 = перегрузка — если постоянно, 0,1 = ничего не происходит |
| **мем** | номер | % |               | Использование памяти. Соотношение между свободной памятью и общей системной памятью |
| **memHeapTotal** | номер | МБ | js-контроллер | Размер кучи памяти, зарезервированной js-контроллером |
| **memHeapUsed** | номер | МБ | js-контроллер | Размер кучи памяти, используемой js-контроллером |
| **мемРсс** | номер | МБ | js-контроллер | Resident Set, общий размер памяти, используемой js-контроллером в оперативной памяти |
| **выходной счетчик** | номер | /15с | js-контроллер | Выходные события включают в себя такие действия, как сравнение значений, запись значения в базу данных состояний, события, связанные с подписками или журналированием. Вот как и здесь происходят события 10+ |
| **memAvailable** | номер | МБ | js-контроллер | (Только в системах *nix) Свободная память доступна для новых запросов к памяти, при этом системе не приходится начинать выгрузку использованной памяти. Рассчитывается на основе MemFree, Active(file), Inactive(file), SReclaimable и нижних порогов из `/proc/zoneinfo`.<br> См. [https://git.kernel.org](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773) |
| **memAvailable** | номер | МБ | js-контроллер | (Только в системах *nix) Свободная память доступна для новых запросов к памяти, при этом системе не приходится начинать выгрузку использованной памяти. Рассчитывается на основе MemFree, Active(file), Inactive(file), SReclaimable и нижних порогов из `/proc/zoneinfo`.<br> См. [https://git.kernel.org](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773) |